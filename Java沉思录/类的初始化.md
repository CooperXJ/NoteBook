### 类的初始化

[参考](https://www.cnblogs.com/zhguang/p/3154584.html)



步骤：

#### 加载->链接->初始化



### 加载

由类加载器执行，查找字节码，并创建一个Class对象（只是创建）



### 链接

1. 验证
   
   - 验证加载类的信息是否符合JVM规范，又没有安全方面的问题。
2. 准备
   
   - 为类变量（static变量）分配内存设置初始值（**不是类中指定的初始值，而是0，null这种初始值 **），该内存在方法区中分配。
3. 解析

   - 将虚拟机常量池中的符号引用替换为直接引用

     **解析的过程就是对类中的接口、类、方法、变量的符号引用进行解析并定位，解析成直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址），并保证这些类被正确的找到**。

     

### 过程详解

![image-20200712143417217](https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20200712143521.png)



首先先要对Demo01进行加载：

- 在方法区中加载Demo01运行的数据，主要包括：

  - 静态变量、静态方法
  - 常量池
  - 类的代码

- 于此同时在堆中生成该类的对象，也可以说是该类的反射对象

  通过该对象可以访问到该类在方法区存放的结构

- 然后加载A类，过程和Demo01差不多

- Demo01的main方法执行时会形成一个栈，然后会有一个a变量存储，但是此时

  a = null，接着new A（）会调用A的构造器并将该构造器压栈（因为构造器本身来说也是一个方法），执行完之后会在堆中生成A的一个对象，然后将该对象的地址赋值给a

- 在加载完成并且连链接成功后，A会在初始化的时候调用静态方法和静态变量



### 初始化

**类只加载一次**

1. 初始化阶段执行类的构造器<clinit>（）的过程，该构造器是由编译器自动收集类中的所有变量赋值动作和静态语句块合并而成。
2. 当初始化一个类的时候如果发现该类的父类还未进行初始化，那么就需要先对其父类进行初始化
3. 虚拟机会保证一个类的<clinit>（）方法在多线程环境中正确的加锁同步
4. 当访问一个类的静态域时，只有真正声明这个域的类才会被初始化

![image-20200712151435227](https://raw.githubusercontent.com/CooperXJ/ImageBed/master/img/20200712151438.png)

