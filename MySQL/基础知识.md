1. reference（参考范围）一般和foreign key 一起使用

   比如说当前有2个表，一为customer表，二为order表

   为了确保所有的order都是来自于customer表中的名单，因此需要加上foreign key(customer_name) references customer(name)

   <font color=red> **InnoDB仅当指定为单独的FOREIGN KEY规范的一部分时才接受REFERENCES子句。**</font>

2. any 和 all 适用于子查询的场景

3. exists

   先进行外部父查询，然后针对父查询的结果集进行子查询，如子查询为true则输出，为false则放弃

   一般来说not exists都要比not in效率高

   exist和in比较如下：

   所以如果父查询所查询的表中的数据越大那么 子查询查询的次数就会越多，这样对效率就很慢，

   <font color=red>子查询需要对父查询中的每一条记录进行查询判断</font>

      例如:

   ​    1 **表a中100000条数据,表b中100条数据，查询数据库次数=1(表a查一次)+100000(子查询：查询表b的次数) ，一共**             **100001次**

   ​     **2 表a中 100条数据，表b100000条，查询数据库次数=1(表a查一次)+100(子查询次数)，一共 101次**

   ​     **可见只有当子查询的表数量远远大于外部表数据的是否用exist查询效率好**

4. 集合运算

   - union和union all

     UNION：将多个查询结果合并起来时，系统自动去掉重复元组
     UNION ALL：将多个查询结果合并起来时，保留重复元组 	

   ```sql
   select *  from Student where age>22 union select * from Student where age=22;
   ```

   - INTERSECT 交集
   - EXCEPT差集

    

